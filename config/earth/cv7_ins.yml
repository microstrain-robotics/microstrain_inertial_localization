/**/microstrain_inertial_driver:
  ros__parameters:
    # This can be set by passing an var to the launch file
    port     : $(var port /dev/microstrain_main)
    baudrate : $(var baudrate 115200)

    # Disable the transform from the mount to frame id transform as it should be handled from a URDF file and robot_description
    publish_mount_to_frame_id_transform : False

    # This will cause the node to convert any NED measurements to ENU
    # This will also cause the node to convert any vehicle frame measurements to the ROS definition of a vehicle frame
    use_enu_frame : True

    # Configure some frame IDs
    frame_id          : $(var frame_id cv7_ins_link)                 # Frame ID of all of the filter messages. Represents the location of the Cv7-INS in the tf tree
    earth_frame_id    : "earth"                                      # Frame ID of the global frame
    target_frame_id   : $(var base_link_frame_id base_link)          # Frame ID that we will publish a transform to.

    # We will use global transform mode, meaning that we will publish the following transforms from this node
    #   earth_frame_id -> target_frame_id
    # This is hard for ROS standard tools to understand, but can be useful for users who do not want to use those tools
    tf_mode: 1

    # (GQ7 only) Filter Initialization control
    #     Auto-Heading alignment selector (note this is a bitfield, you can use more than 1 source) =
    #         Bit 0 - Dual-antenna GNSS
    #         Bit 1 - GNSS kinematic (requires motion, e.g. a GNSS velocity)
    #         Bit 2 - Magnetometer
    #         Bit 3 - External Heading (first valid external heading will be used to initialize the filter)
    # This sets the heading alignment to use only the magnetometer
    filter_auto_heading_alignment_selector : $(var filter_auto_heading_alignment_selector 4)

    # Setup some aiding options.
    filter_enable_gnss_pos_vel_aiding : True
    filter_enable_gnss_heading_aiding : False

    # This example shows a very basic setup with no PPS sync, so the PPS will be generated by the device's oscillator for drift constaint
    # Note that if you have an F9P, it is suggested to setup a PPS line between the two devices
    filter_pps_source : 4

    # Disable the filter declination source. This is required to get the node to start, and isn't doing anything special
    filter_declination_source : 1

    # For this use case, we will not publish any IMU data
    imu_data_rate : 0

    # For this use case, we will not publish any raw GNSS information
    gnss1_llh_position_data_rate   : 0
    gnss1_velocity_data_rate       : 0
    gnss1_odometry_earth_data_rate : 0
    gnss2_llh_position_data_rate   : 0
    gnss2_velocity_data_rate       : 0
    gnss2_odometry_earth_data_rate : 0

    # We will publish the global position in both ECEF and LLH for this example
    # Also publish the human readable message which can be echoed from the command line
    filter_human_readable_status_data_rate : 1
    filter_llh_position_data_rate          : 50
    filter_odometry_earth_data_rate        : 50
    filter_odometry_map_data_rate          : 0

    # Subscribe to the aiding messages.
    # For this example we are just subscribing to external GNSS position and velocity
    subscribe_ext_fix     : True
    subscribe_ext_vel_enu : True

/**/ntrip_client:
  ros__parameters:
    # These can be set by passing args to the launch file
    host       : $(var ntrip_host 192.168.1.1)
    port       : $(var ntrip_port 2101)
    mountpoint : $(var ntrip_mountpoint VRS_RTCM3)

    # For this example, we will always assume that we are going to authenticate
    authenticate : true
    username : $(var ntrip_username user)
    password : $(var ntrip_password pass)

    # Allow SSL, but do not allow custom certs and keys
    ssl : $(var ntrip_ssl false)

    # Since the RTCM will be coming from the RTK base station whose position may be the map frame, set the frame id to map
    rtcm_frame_id : "map"

    # Use the smaller RTCM message option
    rtcm_message_package : "rtcm_msgs"

    # Make sure that we can accept longer NMEA sentences
    nmea_max_length: 128

/**/ublox_f9p:
  ros__parameters:
    # Connect to the requested port
    device: $(var ublox_f9p_port /dev/ttyACM1)

    # Set the frame_id to the user requested frame_id
    frame_id: "ublox_f9p_link"

    # Enable all the constellations
    gnss:
      gps: true
      glonass: true
      galileo: true
      beidou: true

    # Whether to display all INF messages in console
    inf:
      all: true

    # Disable tmode3
    tmode3: 0